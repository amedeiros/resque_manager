var search_data = {"index":{"searchIndex":["object","resque","chainedjobwithstatus","failure","redis","job","jobwithstatus","status","worker","resquescheduler","resqueui","cap","engine","all_workers_in_pid_working()","clear()","completed()","continue()","counter()","counter()","counter_key()","enqueue()","enqueue()","farm_status()","filter_backtrace()","get_rake()","id()","incr_counter()","incr_counter()","ip()","local_ip()","name()","name()","new()","pause()","pause!()","pause_key()","pause_processing()","paused()","paused?()","paused?()","perform()","perform()","pids()","prune_dead_workers()","queue()","queues()","queues_in_pid()","quit()","quit()","restart()","restart()","safe_perform!()","schedule()","schedule=()","shutdown()","start()","start()","startup()","status()","status=()","status_ids()","thread()","throttle()","tick()","to_s()","unpause_processing()","unregister_worker()","work()","workers_in_pid()","working()"],"longSearchIndex":["object","resque","resque::chainedjobwithstatus","resque::failure","resque::failure::redis","resque::job","resque::jobwithstatus","resque::status","resque::worker","resquescheduler","resqueui","resqueui::cap","resqueui::engine","resque::worker#all_workers_in_pid_working()","resque::status::clear()","resque::chainedjobwithstatus#completed()","resque::worker#continue()","resque::jobwithstatus#counter()","resque::status::counter()","resque::status::counter_key()","resque::chainedjobwithstatus::enqueue()","resque::jobwithstatus::enqueue()","resquescheduler::farm_status()","resque::failure::redis#filter_backtrace()","object#get_rake()","resque::worker#id()","resque::jobwithstatus#incr_counter()","resque::status::incr_counter()","resque::worker#ip()","resque::worker#local_ip()","resque::chainedjobwithstatus#name()","resque::jobwithstatus#name()","resque::jobwithstatus::new()","resque::worker#pause()","resque::jobwithstatus#pause!()","resque::worker#pause_key()","resque::worker#pause_processing()","resque::worker#paused()","resque::status#paused?()","resque::worker#paused?()","resque::job#perform()","resque::jobwithstatus::perform()","resquescheduler::pids()","resque::worker#prune_dead_workers()","resque::worker#queue()","resque::worker#queues()","resque::worker#queues_in_pid()","resque::worker#quit()","resquescheduler::quit()","resque::worker#restart()","resquescheduler::restart()","resque::jobwithstatus#safe_perform!()","resquescheduler#schedule()","resquescheduler#schedule=()","resque::worker#shutdown()","resque::worker::start()","resquescheduler::start()","resque::worker#startup()","resque::worker#status()","resque::worker#status=()","resque::status::status_ids()","resque::worker#thread()","resque::throttle()","resque::jobwithstatus#tick()","resque::worker#to_s()","resque::worker#unpause_processing()","resque::worker#unregister_worker()","resque::worker#work()","resque::worker#workers_in_pid()","resque::worker::working()"],"info":[["Object","","Object.html","",""],["Resque","","Resque.html","",""],["Resque::ChainedJobWithStatus","","Resque/ChainedJobWithStatus.html","",""],["Resque::Failure","","Resque/Failure.html","",""],["Resque::Failure::Redis","","Resque/Failure/Redis.html","",""],["Resque::Job","","Resque/Job.html","",""],["Resque::JobWithStatus","","Resque/JobWithStatus.html","",""],["Resque::Status","","Resque/Status.html","",""],["Resque::Worker","","Resque/Worker.html","",""],["ResqueScheduler","","ResqueScheduler.html","",""],["ResqueUi","","ResqueUi.html","",""],["ResqueUi::Cap","","ResqueUi/Cap.html","",""],["ResqueUi::Engine","","ResqueUi/Engine.html","",""],["all_workers_in_pid_working","Resque::Worker","Resque/Worker.html#method-i-all_workers_in_pid_working","()",""],["clear","Resque::Status","Resque/Status.html#method-c-clear","(range_start = nil, range_end = nil)","<p>clear statuses from redis passing an optional range. See `statuses` for\ninfo about ranges\n"],["completed","Resque::ChainedJobWithStatus","Resque/ChainedJobWithStatus.html#method-i-completed","(*messages)",""],["continue","Resque::Worker","Resque/Worker.html#method-i-continue","()",""],["counter","Resque::JobWithStatus","Resque/JobWithStatus.html#method-i-counter","(counter)",""],["counter","Resque::Status","Resque/Status.html#method-c-counter","(counter, uuid)",""],["counter_key","Resque::Status","Resque/Status.html#method-c-counter_key","(counter, uuid)","<p>If multiple workers are running at once and you need an incrementer, you\ncan’t use the status’ num attribute …\n"],["enqueue","Resque::ChainedJobWithStatus","Resque/ChainedJobWithStatus.html#method-c-enqueue","(klass, options = {})",""],["enqueue","Resque::JobWithStatus","Resque/JobWithStatus.html#method-c-enqueue","(klass, options = {})","<p>Adds a job of type &lt;tt&gt;klass&lt;tt&gt; to the queue with\n&lt;tt&gt;options&lt;tt&gt;. Returns the …\n"],["farm_status","ResqueScheduler","ResqueScheduler.html#method-c-farm_status","()",""],["filter_backtrace","Resque::Failure::Redis","Resque/Failure/Redis.html#method-i-filter_backtrace","(backtrace)",""],["get_rake","Object","Object.html#method-i-get_rake","()",""],["id","Resque::Worker","Resque/Worker.html#method-i-id","()",""],["incr_counter","Resque::JobWithStatus","Resque/JobWithStatus.html#method-i-incr_counter","(counter)",""],["incr_counter","Resque::Status","Resque/Status.html#method-c-incr_counter","(counter, uuid)",""],["ip","Resque::Worker","Resque/Worker.html#method-i-ip","()",""],["local_ip","Resque::Worker","Resque/Worker.html#method-i-local_ip","()",""],["name","Resque::ChainedJobWithStatus","Resque/ChainedJobWithStatus.html#method-i-name","()",""],["name","Resque::JobWithStatus","Resque/JobWithStatus.html#method-i-name","()",""],["new","Resque::JobWithStatus","Resque/JobWithStatus.html#method-c-new","(uuid, worker = nil, options = {})","<p>Create a new instance with <code>uuid</code> and <code>options</code>\nOVERRIDE to add the worker attr\n"],["pause","Resque::Worker","Resque/Worker.html#method-i-pause","()",""],["pause!","Resque::JobWithStatus","Resque/JobWithStatus.html#method-i-pause-21","()","<p>Pause the current job, setting the status to ‘paused’\n"],["pause_key","Resque::Worker","Resque/Worker.html#method-i-pause_key","()","<p>When the worker gets the -USR2 signal, to_s may give a different value for\nthe thread and queue portion …\n"],["pause_processing","Resque::Worker","Resque/Worker.html#method-i-pause_processing","()","\n<pre>Stop processing jobs after the current one has completed (if we're\ncurrently running one).</pre>\n<p>OVERRIDE to …\n"],["paused","Resque::Worker","Resque/Worker.html#method-i-paused","()",""],["paused?","Resque::Status","Resque/Status.html#method-i-paused-3F","()","<p>The STATUSES constant is frozen, so we’ll just manually add the paused?\nmethod here\n"],["paused?","Resque::Worker","Resque/Worker.html#method-i-paused-3F","()","<p>are we paused? OVERRIDE so UI can tell if we’re paused\n"],["perform","Resque::Job","Resque/Job.html#method-i-perform","()","<p>Attempts to perform the work represented by this job instance. Calls\n#perform on the class given in the …\n"],["perform","Resque::JobWithStatus","Resque/JobWithStatus.html#method-c-perform","(uuid=nil, options = {})","<p>This is the method called by Resque::Worker when processing jobs. It\ncreates a new instance of the job …\n"],["pids","ResqueScheduler","ResqueScheduler.html#method-c-pids","()","<p>Returns an array of string pids of all the other workers on this machine.\nUseful when pruning dead workers …\n"],["prune_dead_workers","Resque::Worker","Resque/Worker.html#method-i-prune_dead_workers","()","<p>Looks for any workers which should be running on this server and, if\nthey’re not, removes them from  …\n"],["queue","Resque::Worker","Resque/Worker.html#method-i-queue","()",""],["queues","Resque::Worker","Resque/Worker.html#method-i-queues","()","<p>OVERRIDE for multithreaded workers\n"],["queues_in_pid","Resque::Worker","Resque/Worker.html#method-i-queues_in_pid","()",""],["quit","Resque::Worker","Resque/Worker.html#method-i-quit","()",""],["quit","ResqueScheduler","ResqueScheduler.html#method-c-quit","(ips)",""],["restart","Resque::Worker","Resque/Worker.html#method-i-restart","()",""],["restart","ResqueScheduler","ResqueScheduler.html#method-c-restart","(ips)",""],["safe_perform!","Resque::JobWithStatus","Resque/JobWithStatus.html#method-i-safe_perform-21","()","<p>Run by the Resque::Worker when processing this job. It wraps the\n<code>perform</code> method ensuring that the final …\n"],["schedule","ResqueScheduler","ResqueScheduler.html#method-i-schedule","()","<p>Returns the schedule hash\n"],["schedule=","ResqueScheduler","ResqueScheduler.html#method-i-schedule-3D","(schedule_hash)",""],["shutdown","Resque::Worker","Resque/Worker.html#method-i-shutdown","()","\n<pre>Schedule this worker for shutdown. Will finish processing the\ncurrent job.</pre>\n<p>OVERRIDE for multithreaded …\n"],["start","Resque::Worker","Resque/Worker.html#method-c-start","(ips, queues)",""],["start","ResqueScheduler","ResqueScheduler.html#method-c-start","(ips)",""],["startup","Resque::Worker","Resque/Worker.html#method-i-startup","()","\n<pre>Runs all the methods needed when a worker begins its lifecycle.</pre>\n<p>OVERRIDE for multithreaded workers\n"],["status","Resque::Worker","Resque/Worker.html#method-i-status","()",""],["status=","Resque::Worker","Resque/Worker.html#method-i-status-3D","(status)",""],["status_ids","Resque::Status","Resque/Status.html#method-c-status_ids","(range_start = nil, range_end = nil)","\n<pre>Return the &lt;tt&gt;num&lt;/tt&gt; most recent status/job UUIDs in reverse chronological order.</pre>\n<p>override the gem …\n"],["thread","Resque::Worker","Resque/Worker.html#method-i-thread","()",""],["throttle","Resque","Resque.html#method-c-throttle","(queue, limit = 10000, sleep_for = 60)",""],["tick","Resque::JobWithStatus","Resque/JobWithStatus.html#method-i-tick","(*messages)","<p>sets the status of the job for the current iteration. You should use the\n<code>at</code> method if you have actual …\n"],["to_s","Resque::Worker","Resque/Worker.html#method-i-to_s","()","<p>The string representation is the same as the id for this worker instance.\nCan be used with `Worker.find …\n"],["unpause_processing","Resque::Worker","Resque/Worker.html#method-i-unpause_processing","()","\n<pre>Start processing jobs again after a pause</pre>\n<p>OVERRIDE to set remove redis key so UI knows it’s unpaused too …\n"],["unregister_worker","Resque::Worker","Resque/Worker.html#method-i-unregister_worker","()","<p>Unregisters ourself as a worker. Useful when shutting down. OVERRIDE to\nalso remove the pause key Would …\n"],["work","Resque::Worker","Resque/Worker.html#method-i-work","(interval = 5, &block)","\n<pre>This is the main workhorse method. Called on a Worker instance,\nit begins the worker life cycle.\n\nThe ...</pre>\n"],["workers_in_pid","Resque::Worker","Resque/Worker.html#method-i-workers_in_pid","()",""],["working","Resque::Worker","Resque/Worker.html#method-c-working","()","<p>logic for mappged_mget changed where it returns keys with nil values in\nlatest redis gem.\n"]]}}